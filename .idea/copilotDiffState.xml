<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/joystick_server.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/joystick_server.py" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="#!/usr/bin/env python3&#13;&#10;# -*- coding: utf-8 -*-&#13;&#10;&quot;&quot;&quot;&#13;&#10;Servidor continuo para control del AlphaBot2 mediante joystick&#13;&#10;Mantiene los motores inicializados y recibe comandos por socket&#13;&#10;Esto elimina completamente los micro-cortes&#13;&#10;&quot;&quot;&quot;&#13;&#10;&#13;&#10;import socket&#13;&#10;import RPi.GPIO as GPIO&#13;&#10;import sys&#13;&#10;import time&#13;&#10;import threading&#13;&#10;&#13;&#10;# Configuración de pines del AlphaBot2&#13;&#10;AIN1 = 12&#13;&#10;AIN2 = 13&#13;&#10;PWMA = 6&#13;&#10;BIN1 = 20&#13;&#10;BIN2 = 21&#13;&#10;PWMB = 26&#13;&#10;&#13;&#10;# Variable para controlar timeout&#13;&#10;last_command_time = time.time()&#13;&#10;motors_active = False&#13;&#10;TIMEOUT_SECONDS = 0.5  # Detener motores si no hay comandos por 500ms&#13;&#10;&#13;&#10;# Inicializar GPIO una sola vez&#13;&#10;GPIO.setmode(GPIO.BCM)&#13;&#10;GPIO.setwarnings(False)&#13;&#10;GPIO.setup(AIN1, GPIO.OUT)&#13;&#10;GPIO.setup(AIN2, GPIO.OUT)&#13;&#10;GPIO.setup(BIN1, GPIO.OUT)&#13;&#10;GPIO.setup(BIN2, GPIO.OUT)&#13;&#10;GPIO.setup(PWMA, GPIO.OUT)&#13;&#10;GPIO.setup(PWMB, GPIO.OUT)&#13;&#10;&#13;&#10;# Crear objetos PWM (frecuencia 1000 Hz)&#13;&#10;pwm_a = GPIO.PWM(PWMA, 1000)&#13;&#10;pwm_b = GPIO.PWM(PWMB, 1000)&#13;&#10;pwm_a.start(0)&#13;&#10;pwm_b.start(0)&#13;&#10;&#13;&#10;def set_motor_left(speed):&#13;&#10;    &quot;&quot;&quot;Controla el motor izquierdo&quot;&quot;&quot;&#13;&#10;    if speed &gt; 0:&#13;&#10;        GPIO.output(AIN1, GPIO.HIGH)&#13;&#10;        GPIO.output(AIN2, GPIO.LOW)&#13;&#10;        pwm_a.ChangeDutyCycle(min(abs(speed), 100))&#13;&#10;    elif speed &lt; 0:&#13;&#10;        GPIO.output(AIN1, GPIO.LOW)&#13;&#10;        GPIO.output(AIN2, GPIO.HIGH)&#13;&#10;        pwm_a.ChangeDutyCycle(min(abs(speed), 100))&#13;&#10;    else:&#13;&#10;        GPIO.output(AIN1, GPIO.LOW)&#13;&#10;        GPIO.output(AIN2, GPIO.LOW)&#13;&#10;        pwm_a.ChangeDutyCycle(0)&#13;&#10;&#13;&#10;def set_motor_right(speed):&#13;&#10;    &quot;&quot;&quot;Controla el motor derecho&quot;&quot;&quot;&#13;&#10;    if speed &gt; 0:&#13;&#10;        GPIO.output(BIN1, GPIO.HIGH)&#13;&#10;        GPIO.output(BIN2, GPIO.LOW)&#13;&#10;        pwm_b.ChangeDutyCycle(min(abs(speed), 100))&#13;&#10;    elif speed &lt; 0:&#13;&#10;        GPIO.output(BIN1, GPIO.LOW)&#13;&#10;        GPIO.output(BIN2, GPIO.HIGH)&#13;&#10;        pwm_b.ChangeDutyCycle(min(abs(speed), 100))&#13;&#10;    else:&#13;&#10;        GPIO.output(BIN1, GPIO.LOW)&#13;&#10;        GPIO.output(BIN2, GPIO.LOW)&#13;&#10;        pwm_b.ChangeDutyCycle(0)&#13;&#10;&#13;&#10;def joystick_to_motors(x, y):&#13;&#10;    &quot;&quot;&quot;Convierte coordenadas del joystick a velocidades de motores&quot;&quot;&quot;&#13;&#10;    forward = y * 100&#13;&#10;    turn = x * 100&#13;&#10;    &#13;&#10;    left = forward + turn&#13;&#10;    right = forward - turn&#13;&#10;    &#13;&#10;    left = max(-100, min(100, left))&#13;&#10;    right = max(-100, min(100, right))&#13;&#10;    &#13;&#10;    # Zona muerta: si la velocidad es muy baja, ponerla a 0&#13;&#10;    # Esto evita vibraciones o movimientos residuales&#13;&#10;    if abs(left) &lt; 5:&#13;&#10;        left = 0&#13;&#10;    if abs(right) &lt; 5:&#13;&#10;        right = 0&#13;&#10;    &#13;&#10;    return int(left), int(right)&#13;&#10;&#13;&#10;def stop():&#13;&#10;    &quot;&quot;&quot;Detiene ambos motores completamente&quot;&quot;&quot;&#13;&#10;    global motors_active&#13;&#10;    # Asegurar que los motores están completamente apagados&#13;&#10;    GPIO.output(AIN1, GPIO.LOW)&#13;&#10;    GPIO.output(AIN2, GPIO.LOW)&#13;&#10;    GPIO.output(BIN1, GPIO.LOW)&#13;&#10;    GPIO.output(BIN2, GPIO.LOW)&#13;&#10;    pwm_a.ChangeDutyCycle(0)&#13;&#10;    pwm_b.ChangeDutyCycle(0)&#13;&#10;    motors_active = False&#13;&#10;&#13;&#10;def cleanup():&#13;&#10;    &quot;&quot;&quot;Limpia recursos GPIO&quot;&quot;&quot;&#13;&#10;    stop()&#13;&#10;    pwm_a.stop()&#13;&#10;    pwm_b.stop()&#13;&#10;    GPIO.cleanup()&#13;&#10;&#13;&#10;def timeout_watchdog():&#13;&#10;    &quot;&quot;&quot;Thread que monitorea timeout y detiene motores si no hay comandos&quot;&quot;&quot;&#13;&#10;    global last_command_time, motors_active&#13;&#10;    while True:&#13;&#10;        time.sleep(0.1)  # Chequear cada 100ms&#13;&#10;        if motors_active and (time.time() - last_command_time) &gt; TIMEOUT_SECONDS:&#13;&#10;            print(&quot;Timeout detectado - deteniendo motores&quot;)&#13;&#10;            stop()&#13;&#10;&#13;&#10;def start_server(port=5555):&#13;&#10;    &quot;&quot;&quot;Inicia el servidor socket&quot;&quot;&quot;&#13;&#10;    global last_command_time, motors_active&#13;&#10;&#13;&#10;    # Iniciar thread de watchdog&#13;&#10;    watchdog = threading.Thread(target=timeout_watchdog, daemon=True)&#13;&#10;    watchdog.start()&#13;&#10;&#13;&#10;    server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)&#13;&#10;    server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)&#13;&#10;    server_socket.bind(('0.0.0.0', port))&#13;&#10;    server_socket.listen(1)&#13;&#10;&#13;&#10;    print(f&quot;Servidor joystick escuchando en puerto {port}...&quot;)&#13;&#10;    print(f&quot;Timeout automático configurado: {TIMEOUT_SECONDS}s&quot;)&#13;&#10;&#13;&#10;    try:&#13;&#10;        while True:&#13;&#10;            client_socket, address = server_socket.accept()&#13;&#10;            print(f&quot;Conexión establecida desde {address}&quot;)&#13;&#10;&#13;&#10;            try:&#13;&#10;                while True:&#13;&#10;                    data = client_socket.recv(1024).decode('utf-8').strip()&#13;&#10;&#13;&#10;                    if not data:&#13;&#10;                        break&#13;&#10;&#13;&#10;                    # Actualizar timestamp&#13;&#10;                    last_command_time = time.time()&#13;&#10;&#13;&#10;                    # Parsear comando &quot;x y&quot;&#13;&#10;                    parts = data.split()&#13;&#10;                    if len(parts) == 2:&#13;&#10;                        try:&#13;&#10;                            x = float(parts[0])&#13;&#10;                            y = float(parts[1])&#13;&#10;&#13;&#10;                            # Limitar valores&#13;&#10;                            x = max(-1.0, min(1.0, x))&#13;&#10;                            y = max(-1.0, min(1.0, y))&#13;&#10;&#13;&#10;                            # Convertir a velocidades de motor&#13;&#10;                            left_speed, right_speed = joystick_to_motors(x, y)&#13;&#10;&#13;&#10;                            # Aplicar velocidades&#13;&#10;                            set_motor_left(left_speed)&#13;&#10;                            set_motor_right(right_speed)&#13;&#10;                            motors_active = (left_speed != 0 or right_speed != 0)&#13;&#10;&#13;&#10;                            # Respuesta confirmación (opcional)&#13;&#10;                            client_socket.send(b&quot;OK\n&quot;)&#13;&#10;&#13;&#10;                        except ValueError:&#13;&#10;                            client_socket.send(b&quot;ERROR: Invalid values\n&quot;)&#13;&#10;                    elif data.lower() == &quot;stop&quot;:&#13;&#10;                        stop()&#13;&#10;                        client_socket.send(b&quot;STOPPED\n&quot;)&#13;&#10;                    elif data.lower() == &quot;quit&quot;:&#13;&#10;                        stop()&#13;&#10;                        client_socket.send(b&quot;BYE\n&quot;)&#13;&#10;                        break&#13;&#10;&#13;&#10;            except Exception as e:&#13;&#10;                print(f&quot;Error con cliente: {e}&quot;)&#13;&#10;            finally:&#13;&#10;                client_socket.close()&#13;&#10;                stop()  # Detener motores al desconectar&#13;&#10;                print(&quot;Cliente desconectado - motores detenidos&quot;)&#13;&#10;&#13;&#10;    except KeyboardInterrupt:&#13;&#10;        print(&quot;\nServidor detenido por usuario&quot;)&#13;&#10;    finally:&#13;&#10;        server_socket.close()&#13;&#10;        cleanup()&#13;&#10;&#13;&#10;if __name__ == &quot;__main__&quot;:&#13;&#10;    try:&#13;&#10;        start_server()&#13;&#10;    except Exception as e:&#13;&#10;        print(f&quot;Error fatal: {e}&quot;)&#13;&#10;        cleanup()&#13;&#10;        sys.exit(1)" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>